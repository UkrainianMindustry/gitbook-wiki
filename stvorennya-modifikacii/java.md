---
icon: java
---

# Плагіни та JVM моди

Mindustry підтримує завантаження файлів `jar` з байт-кодом Java на настільних комп'ютерах та Android. Вони функціонують аналогічно до JS модів і повинні надавати єдиний головний клас для створення екземпляра при створенні моду.

Теоретично, всі JVM мови повинні підтримуватися.

Jar/JVM моди використовують той самий мета файл `mod.hjson`, що і стандартні моди, з однією додатковою умовою: *повністю кваліфікований головний клас* може бути вказаний за допомогою `main: "mypackage.MyMod"`. Цей клас повинен розширювати `mindustry.mod.Mod`.

Якщо головний клас не вказано, за замовчуванням використовується `modnameinlowercase.ModName + "Mod"`.

Простий `mod.hjson` для Java моду може виглядати так:

```hjson
name: "Nothing"
author: "Yourself"
main: "nothing.NothingMod"
description: "..."
version: "99.99"
```

Дивіться [приклад репозиторію Java моду](https://github.com/Anuken/MindustryJavaModTemplate) або [приклад репозиторію Kotlin моду](https://github.com/Anuken/MindustryKotlinModTemplate) для отримання додаткових інструкцій.

## Плагіни

Плагіни - це Java моди, які призначені для запуску тільки на серверах. Зазвичай вони додають *нові команди* або *нові режими гри*. Всі головні класи плагінів повинні розширювати `mindustry.mod.Plugin`. Це робить їх неявно *прихованими* - клієнтам не потрібно завантажувати плагін для приєднання до сервера. Вони є тільки серверними. Щоб встановити плагін, помістіть JAR у `<server directory>/config/mods/`.

Плагіни називають свій мета файл `plugin.[h]json`. Структура файлу ідентична структурі інших Java модів - дивіться вище для деталей.

Ви можете побачити приклад плагіну [тут](https://github.com/Anuken/MindustryPluginTemplate). Для більш практичного прикладу, який можна використовувати на реальних серверах, дивіться [цей репозиторій](https://github.com/Anuken/AuthorizePlugin).

## Імпорт

На відміну від JS або JSON модів, JAR моди потребують компіляції. Це означає, що їх не можна імпортувати безпосередньо з Github - замість цього використовуються *Github Releases*.

Коли користувач намагається встановити JAR мод, Mindustry перевіряє останній (і *тільки останній*) реліз на Github на наявність артефактів `.jar`. Коли знаходиться перший артефакт, він завантажується на клієнт. Зверніть увагу, що попередні релізи ігноруються.

Я рекомендую використовувати Github Actions (або будь-який інший CI) для автоматичного створення та завантаження jar артефактів до нових релізів.

## Багатопоточність

Якщо не зазначено інше, **жоден код Mindustry не є потокобезпечним**. Виконання будь-яких дій (наприклад, відправка мережевих пакетів, зміна плиток) з потоку, відмінного від основного, призведе до випадкових збоїв або мережевих помилок. Щоб виконати щось в основному потоці, використовуйте `Core.app.post(() -> { /* код */ })`.

## Можливості та безпека

Оскільки jar моди завантажуються безпосередньо через `URLClassLoader` без пісочниці, вони не мають жодних обмежень безпеки. Це означає:

- Можна отримати доступ до всіх Java API.
- Можна використовувати рефлексію для доступу до приватних/прихованих властивостей.
- Моди мають повний доступ до комп'ютера клієнта, що відкриває можливість для потенційно шкідливих дій.
- Моди можуть змінювати файли гри або переписувати основний байт-код.

Таким чином, ви *ніколи не повинні імпортувати jar моди з ненадійних джерел.* Тепер ви можете запитати: Чому jar моди не ізольовані? Хіба це не величезний ризик для безпеки?

Відповідь: *Так*, це так. Однак, немає хороших альтернатив. Навіть якщо я реалізую `SecurityManager` для обмеження можливостей модів, це не допоможе - Java за своєю суттю небезпечна, і будь-яка більш-менш "безпечна" реалізація пісочниці (*якщо така взагалі існує*) вимагатиме відключення рефлексії в модах, що є неприйнятним.

Для порівняння, Forge (*популярний завантажувач модів для Minecraft*) також не ізолює моди.
