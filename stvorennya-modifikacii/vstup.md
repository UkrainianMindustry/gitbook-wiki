---
icon: rocket-launch
---

# Вступ

Модифікації Mindustry - це просто каталоги з ресурсами. Існує багато способів використання API модифікацій, залежно від того, що саме ви хочете зробити і наскільки далеко ви готові зайти.

Ви можете просто змінити існуючий контент гри, створити новий контент за допомогою простішого Json API (що є основним фокусом цієї документації), додати власні звуки (або використовувати існуючі). Можливо додати карти до режиму кампанії та додати скрипти для програмування спеціальної поведінки у вашій модифікації, наприклад, спеціальні ефекти.

Поширення вашої модифікації так само просто, як передати комусь ваш каталог проекту; модифікації також кросплатформенні для будь-якої платформи, яка їх підтримує. Ви захочете використовувати [GitHub](#github) (*або подібний сервіс*) для розміщення вашого вихідного коду.
Для створення модифікацій вам дійсно потрібен будь-який комп'ютер з текстовим редактором.


## Структура Каталогу

Ваш каталог проекту повинен виглядати приблизно так:

    проект
    ├── mod.hjson
    ├── content
    │   ├── items
    │   ├── blocks
    │   ├── liquids
    │   └── units
    ├── maps
    ├── bundles
    ├── sounds
    ├── schematics
    ├── scripts
    ├── sprites-override
    └── sprites

-   `mod.hjson` (обов'язково) файл метаданих для вашої модифікації,
-   `content/*` каталоги для ігрового [Контенту](#content),
-   `maps/` каталог для ігрових карт,
-   `bundles/` каталог для [Пакетів](#bundles),
-   `sounds/` каталог для файлів [Звуків](#sound),
-   `schematics/` каталог для файлів [Схем](#schematic),
-   `scripts/` каталог для [Скриптів](#scripts),
-   `sprites-override/` каталог [Спрайтів](#sprites) для заміни ігрового контенту,
-   `sprites/` каталог [Спрайтів](#sprites) для вашого контенту,

Кожна платформа має різний каталог даних користувача, і саме туди слід розміщувати ваші модифікації:

-   Linux: `~/.local/share/Mindustry/mods/`
-   Steam: `steam/steamapps/common/Mindustry/saves/mods/`
-   Windows: `%appdata%/Mindustry/mods/`
-   MacOS: `~/Library/Application Support/Mindustry/mods/`

*Зверніть увагу, що ваші імена файлів повинні бути написані малими літерами та розділені дефісами:*

-   правильно: `my-custom-block.json`
-   неправильно: `My Custom Block.json`


## Hjson

Mindustry використовує [Hjson](https://hjson.github.io/), що для тих, хто знає Json, є просто надмножиною дуже популярної мови серіалізації, відомої як [Json](https://en.wikipedia.org/wiki/JSON). &#x2013; Це означає, що будь-який дійсний Json буде працювати, але ви отримуєте додаткові корисні можливості:

    # однорядковий коментар

    // однорядковий коментар

    /* багаторядковий
    коментар */

    key1: однорядковий рядок

    key2:
    '''
    багаторядковий
    рядок
    '''

    key3: [ значення 1
            значення 2
            значення 3 ]

    key4: { key1: рядок
            key2: 0 }

Якщо ви не знаєте жодного з цих слів. &#x2013; Мова серіалізації - це просто мова, яка кодує інформацію для програми, а *кодувати* означає перетворювати інформацію з однієї форми в іншу, і в цьому випадку, перетворювати текст у структури даних Java.




## `mod.hjson`

У кореневому каталозі вашого проекту повинен бути файл `mod.json`, який визначає основні метадані вашого проекту. Цей файл також може бути (опціонально) названий `mod.hjson`, щоб потенційно допомогти вашому текстовому редактору вибрати кращу підсвітку синтаксису.

    name: "mod-name"
    displayName: "Це не мод."
    author: Ви самі
    description: "Опис вашого моду"
    version: "1.0"
    minGameVersion: "$latestRelease"
    dependencies: [ ]
    hidden: false

-   `name` буде використовуватися для посилання на ваш мод, тому назвіть його обережно. Повинно бути в kebab-case (без великих літер, пробіли заповнюються '-') і не повинно мати кольорового форматування.
-   `displayName` буде використовуватися як відображуване ім'я для інтерфейсу користувача, яке ви можете використовувати для додавання форматування до цього імені.
-   `description` моду буде відображатися в менеджері модів у грі, тому тримайте його коротким і по суті.
-   `dependencies` є опціональним, якщо ви хочете дізнатися більше про це, перейдіть до розділу [dependencies](#dependencies).
-   `minGameVersion` це мінімальна версія гри. Це **обов'язково** повинно бути числом більше 105.
-   `hidden` визначає, чи є цей мод необхідним для мультиплеєра, за замовчуванням false. Пакети текстур, JS плагіни тощо повинні використовувати це, щоб не викликати конфлікти з серверами та клієнтами відповідно. Як правило, якщо ваш мод створює контент, він не повинен бути прихованим.

## Контент

У кореневому каталозі вашого проекту ви можете мати каталог `content/`, де зберігаються всі дані Json/Hjson. Всередині `content/` є підкаталоги для різних видів контенту, ось поточні загальні:

-   `content/items/` для [предметів](#item), таких як `copper` і `surge-alloy`;
-   `content/blocks/` для [блоків](#block), таких як турелі та підлоги;
-   `content/liquids/` для [рідин](#liquid), таких як `water` і `slag`;
-   `content/units/` для літаючих або наземних [одиниць](#unittype), таких як `eclipse` і `dagger`.

Зверніть увагу, що кожен з цих підкаталогів потребує специфічного типу контенту. Імена файлів у цих каталогах важливі, оскільки основна частина шляху *(ім'я файлу без розширення)* використовується для посилання на нього.

Крім того, файли в цих каталогах `content/<content-type>/*` можуть бути довільно вкладені в інші підкаталоги будь-якого імені, щоб допомогти вам організувати їх далі, наприклад:

-   `content/items/metals/iron.hjson`, що відповідно створить предмет під назвою `iron`.

Зміст цих файлів буде виглядати приблизно так:

    type: TypeOfThing
    name: Name Of Thing
    description: Description of thing.
    # ... більше полів тут ...

|поле|тип|примітки|
|---|---|---|
|type|String|Тип контенту цього об'єкта.|
|name|String|Відображуване ім'я контенту.|
|description|String|Відображуваний опис контенту.|

Інші поля включатимуть поля самого типу.

Варто зазначити, що `name` і `description` не обов'язково повинні бути в структурі json. Ви можете визначити їх для будь-якої мови за допомогою (Bundles)[#bundles]. Однак, якщо вони не присутні ні там, ні там, ім'я буде <type>.<modname>-<stemname>.name і порожній опис відповідно.

## Типи

Типи мають численні поля, але важливим є `type`; це спеціальне поле, яке використовується парсером контенту, що змінює тип вашого об'єкта. *Тип `Router` не може бути типом `Turret`, оскільки вони просто абсолютно різні.*

Типи *розширюють* один одного, тому якщо `MissileBulletType` розширює `BasicBulletType`, ви матимете доступ до всіх полів `BasicBulletType` всередині `MissileBulletType`, таких як `damage`, `lifetime` і `speed`. Поля чутливі до регістру: `hitSize =/= hitsize`.

Що ви можете очікувати від поля, залежить від конкретного типу, деякі типи абсолютно нічого не роблять зі своїми полями і працюють в основному як базові типи, від яких будуть розширюватися інші. Один з таких типів - `Block`.

У цьому прикладі одиниці, тип одиниці - `flying`. Тип `bullet` - `BulletType`, тому ви можете використовувати `MissileBulletType`, оскільки `MissileBulletType` розширює `BulletType`.

Можна також використовувати `mech`, `legs`, `naval` або `payload` як тип одиниці тут.

```hjson
type: flying
weapons: [
  {
    bullet: {
      type: MissileBulletType
      damage: 9000
    }
  }
]
```

Станом на версію `125.1`, типи також можуть бути *повністю кваліфікованим ім'ям класу* Java.

Наприклад, щоб вказати блок як `MendProjector`, ви можете написати
`type: mindustry.world.blocks.defense.MendProjector` замість `type: MendProjector`.

Хоча це не особливо корисно для типів ванілі, це може бути використано для завантаження типів блоків *з інших Java модів* як залежностей.

## Дерево Технологій

Подібно до `type`, існує ще одне магічне поле, відоме як `research`, яке можна додати до кореня будь-якого об'єкта блоку, щоб помістити його в дерево технологій.

    research: duo

Це помістить ваш блок після `duo` в дереві технологій, а щоб помістити його після блоку вашого власного моду, ви повинні написати `<block-name>`, префікс імені моду потрібен лише, якщо ви використовуєте контент з іншого моду.

Вартість дослідження:

|тип|вартість|примітки|
|---|---|---|
|блоки|`requirements ^ 1.1 * 20 * researchCostMultiplier`|`researchCostMultiplier` - це стат, який можна встановити на блоках|
|одиниці|`requirements ^ 1.1 * 50`|---|

Вартість потім округлюється до найближчих 10, 100, 1k, 10k або 100k залежно від того, наскільки висока вартість.

`requirements` - це вартість блоку або одиниці. Одиниці використовують свою вартість побудови/оновлення для розрахунків.

Якщо ви хочете встановити власні вимоги до дослідження, використовуйте цей об'єкт замість просто імені:

    research: {
      parent: duo
      requirements: [
        copper/100
      ]
    }

Це можна використовувати для перевизначення вартості блоків або одиниць, або зробити так, щоб ресурси потрібно було досліджувати, а не просто виробляти їх.

## Спрайти

Все, що вам потрібно для створення спрайтів, це редактор зображень, який підтримує прозорість *(тобто: не Paint).* Спрайти блоків повинні бути `32 * size`, тому блок `2x2` потребуватиме зображення розміром `64x64`. Зображення повинні бути у форматі PNG з 32-бітним форматом пікселів RGBA.
**Будь-який інший формат пікселів, наприклад 16-бітний RGBA, може призвести до аварії Mindustry з помилкою "Pixmap decode error".** Ви можете використовувати командний інструмент `file`, щоб надрукувати інформацію про ваші спрайти:

    file sprites/**.png

Якщо будь-яке з них не має формату 32-бітного RGBA, виправте їх.

Спрайти можна просто помістити в підкаталог `sprites/`. Парсер контенту буде шукати їх рекурсивно.
Зображення упаковуються в "атлас" для ефективного рендерингу. Перший каталог у `sprites/`, наприклад `sprites/blocks`, визначає сторінку в цьому атласі, на яку поміщаються спрайти. Поміщення спрайту блоку на сторінку `units` може спричинити багато затримок; тому ви повинні намагатися організувати речі подібно до того, як це робить [ванільна гра](https://github.com/Anuken/Mindustry/tree/master/core/assets-raw/sprites).

Контент буде шукати спрайти відносно свого власного імені. `content/blocks/my-hail.json` має ім'я `my-hail` і аналогічно `sprites/my-hail.png` має ім'я `my-hail`, тому він буде використовуватися цим контентом.

Контент може шукати кілька спрайтів. `my-hail` може бути туреллю, і він може шукати суфікс `<name>-heat`, що означає, що він буде шукати `my-hail-heat`.

Ви можете знайти всі ванільні спрайти тут:

-   <https://github.com/Anuken/Mindustry/tree/master/core/assets-raw/sprites>

Ще одна річ, яку потрібно знати про спрайти, це те, що деякі з них модифікуються грою. Турелі, зокрема, мають чорну рамку, додану до них, тому ви повинні враховувати це під час створення своїх спрайтів, залишаючи прозорий простір навколо турелей, наприклад: [Ripple](https://raw.githubusercontent.com/Anuken/Mindustry/master/core/assets-raw/sprites/blocks/turrets/ripple.png)

Щоб перевизначити спрайти контенту в грі, ви можете просто помістити їх у `sprites-override/`.
Це видаляє префікс `<modname>-` з їх ідентифікатора, що дозволяє їм перевизначати спрайти з ванілі та навіть інших модів.
Ви також можете використовувати це для створення спрайтів з короткими іменами, такими як `cat`, для зручного використання в скриптах, просто остерігайтеся конфліктів імен з іншими модами.



## Звуки

Користувацькі звуки можна додати через систему модифікацій, помістивши їх у підкаталог `sounds/`. Не має значення, де ви їх розмістите після цього. Підтримуються два формати: `ogg` та `mp3`. Зверніть увагу, що файли `mp3` не можуть безшовно зациклюватися, тому намагайтеся використовувати `ogg` за можливості.

Як і будь-які інші ресурси, ви посилаєтеся на них за основою імені файлу, тому `pewpew.ogg` і `pewpew.mp3` можна посилатися як `pewpew` з поля типу `Sound`.

Ось список вбудованих звуків:

$sounds

## Залежності

Ви можете додати залежності до вашої модифікації, просто додавши імена інших модів у ваш `mod.json`:

    dependencies: [
      other-mod-name
      not-a-mod
    ]

Імена залежностей пишуться малими літерами, а пробіли замінюються дефісами `-`, наприклад, `Other MOD NamE` стає `other-mod-name`.

Щоб посилатися на ресурси інших модів, ви повинні додати префікс з іменем іншого моду:

-   `other-mod-name-not-copper` буде посилатися на `not-copper` у `other-mod-name`
-   `other-mod-name-angry-dagger` буде посилатися на `angry-dagger` у `other-mod-name`
-   `not-a-mod-angry-dagger` буде посилатися на `angry-dagger` у `not-a-mod`



## Мовні пакети

Додатковим доповненням до вашої модифікації є пакети. Основне використання пакетів - це надання перекладів вашого контенту, але немає причин, чому ви не могли б використовувати їх англійською мовою. Це текстові файли, які розміщуються в підкаталозі `bundles/`, і вони повинні мати назви на кшталт `bundle_uk_UA.properties` (для української мови).

Вміст цього файлу дуже простий:

    block.example-mod-silver-wall.name = Срібна стіна
    block.example-mod-silver-wall.description = Стіна зі срібла.

Якщо ви прочитали перші кілька розділів цього посібника, ви відразу це помітите:

-   `<тип контенту>.<назва моду>-<назва контенту>.name`
-   `<тип контенту>.<назва моду>-<назва контенту>.description`

З вашими власними користувацькими рядками для використання в скриптах ви можете використовувати будь-який ключ, який вам подобається:

-    `message.egg = З'їжте свої яйця`
-    `randomline = Випадковий Рядок`

Примітки:

-   назви модів/контенту пишуться малими літерами та розділяються дефісами.

Список типів контенту:

$contentTypes

Список суфіксів пакетів відносно мов:

$bundles


## GitHub

Як тільки у вас буде якась модифікація, ви захочете поділитися нею, і, можливо, навіть працювати над нею з іншими людьми. Для цього ви можете використовувати [GitHub](https://github.com/). Якщо ви взагалі не знаєте, що таке Git (або GitHub), то вам слід ознайомитися з [GitHub Desktop](https://desktop.github.com/), в іншому випадку просто використовуйте ваш улюблений інструмент командного рядка або плагін текстового редактора.

Все, що вам потрібно зрозуміти, це як відкривати репозиторії на GitHub, ставити та комітити зміни у вашому локальному репозиторії та відправляти зміни до репозиторію на GitHub. Як тільки ваш проект буде на GitHub, є три способи поділитися ним:

-   за допомогою кінцевої точки, наприклад `Anuken/MindustryJavaModTemplate`, яку можна ввести в ігровий інтерфейс GitHub, і це завантажить його;
-   за допомогою zip-файлу, наприклад `https://github.com/Anuken/MindustryJavaModTemplate/archive/master.zip`, який завантажить репозиторій як zip-файл і помістить його в каталог модів (розпаковувати не потрібно);
-   додайте тег `mindustry-mod` до вашого репозиторію, що повинно додати його до пошуку за тегами та [Mod scraper](https://github.com/Anuken/MindustryMods).



## Поширені запитання

-   `time` в грі обчислюється через `ticks`;
-   `ticks` *іноді називаються `frames`,* вважаються рівними 1/60 секунди;
-   `tilesize` внутрішньо дорівнює 8 одиницям;
-   щоб обчислити дальність з `lifetime` і `speed`, можна зробити `lifetime * speed = range`;
-   *Abstract* що таке `abstract`? Все, що вам потрібно знати про абстрактні типи, це те, що їх не можна ініціалізувати самостійно. Якщо ви це зробите, ви отримаєте *"initialization exception"* якогось типу;
-   що таке `NullPointerException`? Це повідомлення про помилку, яке вказує на те, що поле є null і не повинно бути null, тобто одне з обов'язкових полів може бути відсутнім;
-   *bleeding-edge* що таке `bleeding-edge`? Це версія розробника Mindustry, конкретно це стосується гілки master на GitHub. Зміни на bleeding-edge зазвичай потрапляють у Mindustry в наступному випуску.



